{
  "_args": [
    [
      {
        "raw": "graphql-anywhere@^4.1.0-alpha.0",
        "scope": null,
        "escapedName": "graphql-anywhere",
        "name": "graphql-anywhere",
        "rawSpec": "^4.1.0-alpha.0",
        "spec": ">=4.1.0-alpha.0 <5.0.0",
        "type": "range"
      },
      "/Users/thoriqnurfaizal/Documents/GitHub/AdvancedReact/Frontend/node_modules/apollo-link-state"
    ]
  ],
  "_from": "graphql-anywhere@^4.1.0-alpha.0",
  "_hasShrinkwrap": false,
  "_id": "graphql-anywhere@4.1.19",
  "_location": "/graphql-anywhere",
  "_nodeVersion": "8.11.2",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/graphql-anywhere_4.1.19_1536745090297_0.5537676342920579"
  },
  "_npmUser": {
    "name": "mdg",
    "email": "npm@meteor.com"
  },
  "_npmVersion": "5.6.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "graphql-anywhere@^4.1.0-alpha.0",
    "scope": null,
    "escapedName": "graphql-anywhere",
    "name": "graphql-anywhere",
    "rawSpec": "^4.1.0-alpha.0",
    "spec": ">=4.1.0-alpha.0 <5.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/apollo-link-state"
  ],
  "_resolved": "https://registry.npmjs.org/graphql-anywhere/-/graphql-anywhere-4.1.19.tgz",
  "_shasum": "5f6ca3b58218e5449f4798e3c6d942fcd2fef082",
  "_shrinkwrap": null,
  "_spec": "graphql-anywhere@^4.1.0-alpha.0",
  "_where": "/Users/thoriqnurfaizal/Documents/GitHub/AdvancedReact/Frontend/node_modules/apollo-link-state",
  "author": {
    "name": "Sashko Stubailo",
    "email": "sashko@stubailo.com"
  },
  "bugs": {
    "url": "https://github.com/apollographql/graphql-anywhere/issues"
  },
  "contributors": [
    {
      "name": "James Burgess",
      "email": "jamesmillerburgess@gmail.com"
    }
  ],
  "dependencies": {
    "apollo-utilities": "^1.0.21"
  },
  "description": "Run GraphQL queries with no schema and just one resolver",
  "devDependencies": {},
  "directories": {},
  "dist": {
    "integrity": "sha512-mQlvbECzYPBcgBC9JsdM4v+DSvNmcIP+8Vwr+ij3gktbaLSE0Iza30mztuz40Jlf7ooMs+0emBZucNjLzqz7tA==",
    "shasum": "5f6ca3b58218e5449f4798e3c6d942fcd2fef082",
    "tarball": "https://registry.npmjs.org/graphql-anywhere/-/graphql-anywhere-4.1.19.tgz",
    "fileCount": 33,
    "unpackedSize": 139051,
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbmN6DCRA9TVsSAnZWagAApeAP/27eaRXWFY+FhSj6YkeQ\nZaiQdefrCuupeVTWZm7bL9rjnXDJAYmQ/OPDXQs+dZrItKCM+FAH15ye5q8R\nUJSqh67KE2uvsh8KK4vJ6pTr8TRjGJcTz85Y81YOkkE2IdQKdse581gqbCLw\nH9iR6wxVTW0Al+Dkv+2qzbH/X+4AWOdQU/Eb8ATbOuvohWOTv10Dj/FgWnQV\nJb0JGzMt5BeqbKia0PgUqwEs/it0sdWnhQFSCVbSTfxZl38K3O14tKBIlYGg\nz8vQzs/X8CSjomi/ZPX0FvY+Oz05jM2/vKORzUmrMv3lRYrQdV1eOp/vjfzk\nwxa9eWgAfF7CP/+gtRDCkEQYmfIVgzr/ZOWazsB+qESWbS8XRyB4gEVIA3Df\nlgwugjmngXJI5S2C2qXCYyok3B2Zh22t+Q6dyXLfpjfd6PCsqkeB53JbOw7d\nP3uT2+7kAN5xaFxk0Hdlh0P2Pbir9vMyvONhh0CrZd4Yc8ho80CXM0BRx3Tj\noxJhzw1YWHWGhh8WebDmvSl2lZ9I6Rbg0UM8ZbmkFXcrY6gsPJEPfUETyILa\nf30z8Jg647rQMowcEw7AF3ywrEsCDflTqcX9BJN9pVWrMYp1qD0MgE+W0g5f\nzDfYvQ78/OYj7lylAVbhU+T8EgMSFiWPJF4kUAx4Pm0fEJ9HZPI+gy5wVWvu\nsXQu\r\n=502e\r\n-----END PGP SIGNATURE-----\r\n"
  },
  "gitHead": "6b8a3651d85c0b9eaa88385caf970905f497cf21",
  "homepage": "https://github.com/apollographql/graphql-anywhere#readme",
  "jest": {
    "transform": {
      ".(ts|tsx)": "ts-jest"
    },
    "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
    "moduleFileExtensions": [
      "ts",
      "tsx",
      "js",
      "json"
    ],
    "testURL": "http://localhost"
  },
  "jsnext:main": "./lib/index.js",
  "keywords": [
    "ecmascript",
    "es2015",
    "jsnext",
    "javascript",
    "relay",
    "npm",
    "react"
  ],
  "license": "MIT",
  "main": "./lib/bundle.umd.js",
  "maintainers": [
    {
      "name": "benjamn",
      "email": "ben@benjamn.com"
    },
    {
      "name": "helfer",
      "email": "jonas@helfer.email"
    },
    {
      "name": "jbaxleyiii",
      "email": "james@meteor.com"
    },
    {
      "name": "mdg",
      "email": "npm@meteor.com"
    },
    {
      "name": "peggyrayzis",
      "email": "peggyrayzis@gmail.com"
    },
    {
      "name": "sashko",
      "email": "s.stubailo@gmail.com"
    },
    {
      "name": "tmeasday",
      "email": "tom@thesnail.org"
    }
  ],
  "module": "./lib/index.js",
  "name": "graphql-anywhere",
  "optionalDependencies": {},
  "readme": "# graphql-anywhere\n\n[![npm version](https://badge.fury.io/js/graphql-anywhere.svg)](https://badge.fury.io/js/graphql-anywhere)\n[![Build Status](https://travis-ci.org/apollographql/graphql-anywhere.svg?branch=master)](https://travis-ci.org/apollostack/graphql-anywhere)\n\nRun a GraphQL query anywhere, without a GraphQL server or a schema. Just pass in one resolver. Use it together with [graphql-tag](https://github.com/apollographql/graphql-tag).\n\n```\nnpm install graphql-anywhere graphql-tag\n```\n\nI think there are a lot of potentially exciting use cases for a completely standalone and schema-less GraphQL execution engine. We use it in [Apollo Client](https://github.com/apollostack/apollo-client) to read data from a Redux store with GraphQL.\n\nLet's come up with some more ideas - below are some use cases to get you started!\n\n## API\n\n```js\nimport graphql from 'graphql-anywhere'\n\ngraphql(resolver, document, rootValue?, context?, variables?, options?)\n```\n\n- `resolver`: A single resolver, called for every field on the query.\n    - Signature is: `(fieldName, rootValue, args, context, info) => any`\n- `document`: A GraphQL document, as generated by the template literal from `graphql-tag`\n- `rootValue`: The root value passed to the resolver when executing the root fields\n- `context`: A context object passed to the resolver for every field\n- `variables`: A dictionary of variables for the query\n- `options`: Options for execution\n\n#### Options\n\nThe last argument to the `graphql` function is a set of `graphql-anywhere`-specific options.\n\n- `resultMapper`: Transform field results after execution.\n    - Signature is: `(resultFields, resultRoot) => any`\n- `fragmentMatcher`: Decide whether to execute a fragment. Default is to always execute all fragments.\n    - Signature is: `(rootValue, typeCondition, context) => boolean`\n\n#### Resolver info\n\n`info`, the 5th argument to the resolver, is an object with supplementary information about execution. Send a PR or open an issue if you need additional information here.\n\n- `isLeaf`: A boolean that is `true` if this resolver is for a leaf field of the query, i.e. one that doesn't have a sub-selection.\n- `resultKey`: The key the result of this field will be put under. It's either the field name from the query, or the field alias.\n- `directives`: An object with information about all directives on this field. It's an object of the format `{ [directiveName]: { [argumentName]: value }}`. So for example a field with `@myDirective(hello: \"world\")` will be passed as `{ myDirective: { hello: 'world' }}`. Note that fields can't have multiple directives with the same name, as written in the GraphQL spec.\n\n\n## Utilities\n\nSee https://www.apollographql.com/docs/react/advanced/fragments.html for examples of how you might use these.\n\n```js\nimport { filter } from 'graphql-anywhere'\n\nfilter(doc, data);\n```\n\n- `doc`: a GraphQL document, as generated by the template literal from `graphql-tag`, typically either a query or a fragment.\n- `data`: an object of data to be filtered by the `doc`\n\nFilter `data` according to `doc`.\n\n\n```js\nimport { check } from 'graphql-anywhere'\n\ncheck(doc, data);\n```\n\n- `doc`: a GraphQL document, as generated by the template literal from `graphql-tag`, typically either a query or a fragment.\n- `data`: an object of data, as may have been filtered by `doc`.\n\nCheck that `data` is of the form defined by the query or fragment. Throw an exception if not.\n\n```js\nimport { propType } from 'graphql-anywhere'\n\nX.propTypes = {\n  foo: propType(doc),\n  bar: propType(doc).isRequired,\n}\n\n```\n\n- `doc`: a GraphQL document, as generated by the template literal from `graphql-tag`, typically either a query or a fragment.\n\nGenerate a React `propType` checking function to ensure that the passed prop is in the right form.\n\n### Supported GraphQL features\n\nWhy do you even need a library for this? Well, running a GraphQL query isn't as simple as just traversing the AST, since there are some pretty neat features that make the language a bit more complex to execute.\n\n- [x] Arguments\n- [x] Variables\n- [x] Aliases\n- [x] Fragments, both named and inline\n- [x] `@skip` and `@include` directives\n\nIf you come across a GraphQL feature not supported here, please file an issue.\n\n<a id=\"filter\"></a>\n## Example: Filter a nested object\n\n```js\nimport gql from 'graphql-tag';\nimport graphql from 'graphql-anywhere';\n\n// I don't need all this stuff!\nconst gitHubAPIResponse = {\n  \"url\": \"https://api.github.com/repos/octocat/Hello-World/issues/1347\",\n  \"title\": \"Found a bug\",\n  \"body\": \"I'm having a problem with this.\",\n  \"user\": {\n    \"login\": \"octocat\",\n    \"avatar_url\": \"https://github.com/images/error/octocat_happy.gif\",\n    \"url\": \"https://api.github.com/users/octocat\",\n  },\n  \"labels\": [\n    {\n      \"url\": \"https://api.github.com/repos/octocat/Hello-World/labels/bug\",\n      \"name\": \"bug\",\n      \"color\": \"f29513\"\n    }\n  ],\n};\n\n// Write a query that gets just the fields we want\nconst query = gql`\n  {\n    title\n    user {\n      login\n    }\n    labels {\n      name\n    }\n  }\n`;\n\n// Define a resolver that just returns a property\nconst resolver = (fieldName, root) => root[fieldName];\n\n// Filter the data!\nconst result = graphql(\n  resolver,\n  query,\n  gitHubAPIResponse\n);\n\nassert.deepEqual(result, {\n  \"title\": \"Found a bug\",\n  \"user\": {\n    \"login\": \"octocat\",\n  },\n  \"labels\": [\n    {\n      \"name\": \"bug\",\n    }\n  ],\n});\n```\n\n<a id=\"mock\"></a>\n## Example: Generate mock data\n\n```js\n// Write a query where the fields are types, but we alias them\nconst query = gql`\n  {\n    author {\n      name: string\n      age: int\n      address {\n        state: string\n      }\n    }\n  }\n`;\n\n// Define a resolver that uses the field name to determine the type\n// Note that we get the actual name, not the alias, but the alias\n// is used to determine the location in the response\nconst resolver = (fieldName) => ({\n  string: 'This is a string',\n  int: 5,\n}[fieldName] || 'continue');\n\n// Generate the object!\nconst result = graphql(\n  resolver,\n  query\n);\n\nassert.deepEqual(result, {\n  author: {\n    name: 'This is a string',\n    age: 5,\n    address: {\n      state: 'This is a string',\n    },\n  },\n});\n```\n<a id=\"normalizr\"></a>\n## Example: Read from a Redux store generated with Normalizr\n\n```js\nconst data = {\n  result: [1, 2],\n  entities: {\n    articles: {\n      1: { id: 1, title: 'Some Article', author: 1 },\n      2: { id: 2, title: 'Other Article', author: 1 },\n    },\n    users: {\n      1: { id: 1, name: 'Dan' },\n    },\n  },\n};\n\nconst query = gql`\n  {\n    result {\n      title\n      author {\n        name\n      }\n    }\n  }\n`;\n\nconst schema = {\n  articles: {\n    author: 'users',\n  },\n};\n\n// This resolver is a bit more complex than others, since it has to\n// correctly handle the root object, values by ID, and scalar leafs.\nconst resolver = (fieldName, rootValue, args, context): any => {\n  if (!rootValue) {\n    return context.result.map((id) => assign({}, context.entities.articles[id], {\n      __typename: 'articles',\n    }));\n  }\n\n  const typename = rootValue.__typename;\n  // If this field is a reference according to the schema\n  if (typename && schema[typename] && schema[typename][fieldName]) {\n    // Get the target type, and get it from entities by ID\n    const targetType: string = schema[typename][fieldName];\n    return assign({}, context.entities[targetType][rootValue[fieldName]], {\n      __typename: targetType,\n    });\n  }\n\n  // This field is just a scalar\n  return rootValue[fieldName];\n};\n\nconst result = graphql(\n  resolver,\n  query,\n  null,\n  data // pass data as context since we have to access it all the time\n);\n\n// This is the non-normalized data, with only the fields we asked for in our query!\nassert.deepEqual(result, {\n  result: [\n    {\n      title: 'Some Article',\n      author: {\n        name: 'Dan',\n      },\n    },\n    {\n      title: 'Other Article',\n      author: {\n        name: 'Dan',\n      },\n    },\n  ],\n});\n```\n\n## Example: Generate React components\n\nYou can use the `resultMapper` option to convert your results into anything you like. In this case, we convert the result fields into children for a React component:\n\n```js\nconst resolver = (fieldName, root, args) => {\n  if (fieldName === 'text') {\n    return args.value;\n  }\n\n  return createElement(fieldName, args);\n};\n\nconst reactMapper = (childObj, root) => {\n  const reactChildren = Object.keys(childObj).map(key => childObj[key]);\n\n  if (root) {\n    return cloneElement(root, root.props, ...reactChildren);\n  }\n\n  return reactChildren[0];\n};\n\nfunction gqlToReact(query): any {\n  return graphql(\n    resolver,\n    query,\n    '',\n    null,\n    null,\n    { resultMapper: reactMapper },\n  );\n}\n\nconst query = gql`\n  {\n    div {\n      s1: span(id: \"my-id\") {\n        text(value: \"This is text\")\n      }\n      s2: span\n    }\n  }\n`;\n\nassert.equal(\n  renderToStaticMarkup(gqlToReact(query)),\n  '<div><span id=\"my-id\">This is text</span><span></span></div>'\n);\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/apollographql/graphql-anywhere.git"
  },
  "scripts": {
    "build": "tsc",
    "bundle": "../../node_modules/rollup/bin/rollup -c rollup.config.js && ../../node_modules/rollup/bin/rollup -c rollup.async.config.js",
    "clean": "rm -rf coverage/* && rm -rf lib/*",
    "coverage": "jest --coverage",
    "filesize": "npm run minify",
    "lint": "tslint -c \"../../config/tslint.json\" -p tsconfig.json src/*.ts",
    "minify": "../../node_modules/uglify-js/bin/uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.umd.js",
    "postbuild": "npm run bundle",
    "prepare": "npm run lint && npm run build",
    "prepublishOnly": "npm run build",
    "test": "jest",
    "watch": "tsc -w"
  },
  "sideEffects": false,
  "typings": "./lib/index.d.ts",
  "version": "4.1.19"
}
