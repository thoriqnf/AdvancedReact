{
  "_args": [
    [
      {
        "raw": "jest-each@^23.6.0",
        "scope": null,
        "escapedName": "jest-each",
        "name": "jest-each",
        "rawSpec": "^23.6.0",
        "spec": ">=23.6.0 <24.0.0",
        "type": "range"
      },
      "/Users/thoriqnurfaizal/Documents/GitHub/AdvancedReact/Frontend/node_modules/jest-jasmine2"
    ]
  ],
  "_from": "jest-each@^23.6.0",
  "_hasShrinkwrap": false,
  "_id": "jest-each@23.6.0",
  "_location": "/jest-each",
  "_nodeVersion": "8.9.1",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/jest-each_23.6.0_1536583380046_0.7077175847113457"
  },
  "_npmUser": {
    "name": "mjesun",
    "email": "mjesun@hotmail.com"
  },
  "_npmVersion": "5.5.1",
  "_phantomChildren": {},
  "_requested": {
    "raw": "jest-each@^23.6.0",
    "scope": null,
    "escapedName": "jest-each",
    "name": "jest-each",
    "rawSpec": "^23.6.0",
    "spec": ">=23.6.0 <24.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/jest-jasmine2"
  ],
  "_resolved": "https://registry.npmjs.org/jest-each/-/jest-each-23.6.0.tgz",
  "_shasum": "ba0c3a82a8054387016139c733a05242d3d71575",
  "_shrinkwrap": null,
  "_spec": "jest-each@^23.6.0",
  "_where": "/Users/thoriqnurfaizal/Documents/GitHub/AdvancedReact/Frontend/node_modules/jest-jasmine2",
  "author": {
    "name": "Matt Phillips",
    "url": "mattphillips"
  },
  "bugs": {
    "url": "https://github.com/facebook/jest/issues"
  },
  "dependencies": {
    "chalk": "^2.0.1",
    "pretty-format": "^23.6.0"
  },
  "description": "Parameterised tests for Jest",
  "devDependencies": {},
  "directories": {},
  "dist": {
    "integrity": "sha512-x7V6M/WGJo6/kLoissORuvLIeAoyo2YqLOoCDkohgJ4XOXSqOtyvr8FbInlAWS77ojBsZrafbozWoKVRdtxFCg==",
    "shasum": "ba0c3a82a8054387016139c733a05242d3d71575",
    "tarball": "https://registry.npmjs.org/jest-each/-/jest-each-23.6.0.tgz",
    "fileCount": 4,
    "unpackedSize": 20878,
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJblmbUCRA9TVsSAnZWagAAsKsP/0N5NhHv07Xu0Ti6IPqR\n5gfvTaD/+RxgQQx5PmzCiVsVP/OqvJiFdlYV7bwLLwdsqT/DfJ+kciWRRVaj\nAmF3O/Y0pgkxeBSgbyN2hEPwPpGTRa2i8KItOfQefOIDXAL6gM5QrhTaoDbv\nXI2XWvvYd9Yj9XWB+mLp696DgEaZ4Dx7tbq3ADGtimWOt1kUsQNYSKdCPQZj\njqqESxj8m+A2BASOnpZFm7nvJzTeu3uPgpWzTfKyi9qrwmaJ07ONtdV7REYb\nzCM8yZ4vovdPgvqoSS+OWx/ShM1SmTA7p4GCk3JPKHhhOVONG0JOCwHT5Y2Z\nMkQLUOvBuae/2id40aYZTvkNgx1EO5psRLROP2GpqM/OwhHG995wMgMSoSb6\nIz2duZCBRkpRny1uOGb2HD2+fIxMq/9Z1Tf4J/5wuxdAto8184jW0wS9SI41\n0InyyGrlpob/v9ijUPkRcv8DG3Im5Co10LU5+0BnqVfjE6BqIo+uTK+7dFNB\n1BksdzTEJjPfg4fXQz05rvrYD4pIZbfvXvKTPI5kZ9b73Oy652LCf8LQkXoh\niRSY4PPSFP/Qz5X0R96r2j0TqnKTTz+Q2P8exFglMhQv619AmbfY8IhEtYF4\nHIjQH4yGFKnhD/BT9eCQ4p5e+CGowWyK38HAzB81WUlDPwx94BdORazkH/G5\ntPFH\r\n=GWho\r\n-----END PGP SIGNATURE-----\r\n"
  },
  "homepage": "https://github.com/facebook/jest#readme",
  "keywords": [
    "jest",
    "parameterised",
    "test",
    "each"
  ],
  "license": "MIT",
  "main": "build/index.js",
  "maintainers": [
    {
      "name": "mattphillips",
      "email": "matt@mattphillips.io"
    }
  ],
  "name": "jest-each",
  "optionalDependencies": {},
  "readme": "<div align=\"center\">\n  <h1>jest-each</h1>\n  Jest Parameterised Testing\n</div>\n\n<hr />\n\n[![version](https://img.shields.io/npm/v/jest-each.svg?style=flat-square)](https://www.npmjs.com/package/jest-each) [![downloads](https://img.shields.io/npm/dm/jest-each.svg?style=flat-square)](http://npm-stat.com/charts.html?package=jest-each&from=2017-03-21) [![MIT License](https://img.shields.io/npm/l/jest-each.svg?style=flat-square)](https://github.com/facebook/jest/blob/master/LICENSE)\n\nA parameterised testing library for [Jest](https://jestjs.io/) inspired by [mocha-each](https://github.com/ryym/mocha-each).\n\njest-each allows you to provide multiple arguments to your `test`/`describe` which results in the test/suite being run once per row of parameters.\n\n## Features\n\n- `.test` to runs multiple tests with parameterised data\n  - Also under the alias: `.it`\n- `.test.only` to only run the parameterised tests\n  - Also under the aliases: `.it.only` or `.fit`\n- `.test.skip` to skip the parameterised tests\n  - Also under the aliases: `.it.skip` or `.xit` or `.xtest`\n- `.describe` to runs test suites with parameterised data\n- `.describe.only` to only run the parameterised suite of tests\n  - Also under the aliases: `.fdescribe`\n- `.describe.skip` to skip the parameterised suite of tests\n  - Also under the aliases: `.xdescribe`\n- Asynchronous tests with `done`\n- Unique test titles with [`printf` formatting](https://nodejs.org/api/util.html#util_util_format_format_args):\n  - `%p` - [pretty-format](https://www.npmjs.com/package/pretty-format).\n  - `%s`- String.\n  - `%d`- Number.\n  - `%i` - Integer.\n  - `%f` - Floating point value.\n  - `%j` - JSON.\n  - `%o` - Object.\n  - `%#` - Index of the test case.\n  - `%%` - single percent sign ('%'). This does not consume an argument.\n- ðŸ–– Spock like data tables with [Tagged Template Literals](#tagged-template-literal-of-rows)\n\n---\n\n- [Demo](#demo)\n- [Installation](#installation)\n- [Importing](#importing)\n- APIs\n  - [Array of Rows](#array-of-rows)\n    - [Usage](#usage)\n  - [Tagged Template Literal of rows](#tagged-template-literal-of-rows)\n    - [Usage](#usage-1)\n\n## Demo\n\n#### Tests without jest-each\n\n![Current jest tests](assets/default-demo.gif)\n\n#### Tests can be re-written with jest-each to:\n\n**`.test`**\n\n![Current jest tests](assets/test-demo.gif)\n\n**`.test` with Tagged Template Literals**\n\n![Current jest tests](assets/tagged-template-literal.gif)\n\n**`.describe`**\n\n![Current jest tests](assets/describe-demo.gif)\n\n## Installation\n\n`npm i --save-dev jest-each`\n\n`yarn add -D jest-each`\n\n## Importing\n\njest-each is a default export so it can be imported with whatever name you like.\n\n```js\n// es6\nimport each from 'jest-each';\n```\n\n```js\n// es5\nconst each = require('jest-each');\n```\n\n## Array of rows\n\n### API\n\n#### `each([parameters]).test(name, testFn)`\n\n##### `each`:\n\n- parameters: `Array` of Arrays with the arguments that are passed into the `testFn` for each row\n  - _Note_ If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. `[1, 2, 3] -> [[1], [2], [3]]`\n\n##### `.test`:\n\n- name: `String` the title of the `test`.\n  - Generate unique test titles by positionally injecting parameters with [`printf` formatting](https://nodejs.org/api/util.html#util_util_format_format_args):\n    - `%p` - [pretty-format](https://www.npmjs.com/package/pretty-format).\n    - `%s`- String.\n    - `%d`- Number.\n    - `%i` - Integer.\n    - `%f` - Floating point value.\n    - `%j` - JSON.\n    - `%o` - Object.\n    - `%#` - Index of the test case.\n    - `%%` - single percent sign ('%'). This does not consume an argument.\n- testFn: `Function` the test logic, this is the function that will receive the parameters of each row as function arguments\n\n#### `each([parameters]).describe(name, suiteFn)`\n\n##### `each`:\n\n- parameters: `Array` of Arrays with the arguments that are passed into the `suiteFn` for each row\n  - _Note_ If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. `[1, 2, 3] -> [[1], [2], [3]]`\n\n##### `.describe`:\n\n- name: `String` the title of the `describe`\n  - Generate unique test titles by positionally injecting parameters with [`printf` formatting](https://nodejs.org/api/util.html#util_util_format_format_args):\n    - `%p` - [pretty-format](https://www.npmjs.com/package/pretty-format).\n    - `%s`- String.\n    - `%d`- Number.\n    - `%i` - Integer.\n    - `%f` - Floating point value.\n    - `%j` - JSON.\n    - `%o` - Object.\n    - `%#` - Index of the test case.\n    - `%%` - single percent sign ('%'). This does not consume an argument.\n- suiteFn: `Function` the suite of `test`/`it`s to be ran, this is the function that will receive the parameters in each row as function arguments\n\n### Usage\n\n#### `.test(name, fn)`\n\nAlias: `.it(name, fn)`\n\n```js\neach([[1, 1, 2], [1, 2, 3], [2, 1, 3]]).test(\n  'returns the result of adding %d to %d',\n  (a, b, expected) => {\n    expect(a + b).toBe(expected);\n  },\n);\n```\n\n#### `.test.only(name, fn)`\n\nAliases: `.it.only(name, fn)` or `.fit(name, fn)`\n\n```js\neach([[1, 1, 2], [1, 2, 3], [2, 1, 3]]).test.only(\n  'returns the result of adding %d to %d',\n  (a, b, expected) => {\n    expect(a + b).toBe(expected);\n  },\n);\n```\n\n#### `.test.skip(name, fn)`\n\nAliases: `.it.skip(name, fn)` or `.xit(name, fn)` or `.xtest(name, fn)`\n\n```js\neach([[1, 1, 2][(1, 2, 3)], [2, 1, 3]]).test.skip(\n  'returns the result of adding %d to %d',\n  (a, b, expected) => {\n    expect(a + b).toBe(expected);\n  },\n);\n```\n\n#### Asynchronous `.test(name, fn(done))`\n\nAlias: `.it(name, fn(done))`\n\n```js\neach([['hello'], ['mr'], ['spy']]).test(\n  'gives 007 secret message: %s',\n  (str, done) => {\n    const asynchronousSpy = message => {\n      expect(message).toBe(str);\n      done();\n    };\n    callSomeAsynchronousFunction(asynchronousSpy)(str);\n  },\n);\n```\n\n#### `.describe(name, fn)`\n\n```js\neach([[1, 1, 2], [1, 2, 3], [2, 1, 3]]).describe(\n  '.add(%d, %d)',\n  (a, b, expected) => {\n    test(`returns ${expected}`, () => {\n      expect(a + b).toBe(expected);\n    });\n\n    test('does not mutate first arg', () => {\n      a + b;\n      expect(a).toBe(a);\n    });\n\n    test('does not mutate second arg', () => {\n      a + b;\n      expect(b).toBe(b);\n    });\n  },\n);\n```\n\n#### `.describe.only(name, fn)`\n\nAliases: `.fdescribe(name, fn)`\n\n```js\neach([[1, 1, 2], [1, 2, 3], [2, 1, 3]]).describe.only(\n  '.add(%d, %d)',\n  (a, b, expected) => {\n    test(`returns ${expected}`, () => {\n      expect(a + b).toBe(expected);\n    });\n  },\n);\n```\n\n#### `.describe.skip(name, fn)`\n\nAliases: `.xdescribe(name, fn)`\n\n```js\neach([[1, 1, 2], [1, 2, 3], [2, 1, 3]]).describe.skip(\n  '.add(%d, %d)',\n  (a, b, expected) => {\n    test(`returns ${expected}`, () => {\n      expect(a + b).toBe(expected);\n    });\n  },\n);\n```\n\n---\n\n## Tagged Template Literal of rows\n\n### API\n\n#### `each[tagged template].test(name, suiteFn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.test('returns $expected when adding $a to $b', ({a, b, expected}) => {\n  expect(a + b).toBe(expected);\n});\n```\n\n##### `each` takes a tagged template string with:\n\n- First row of variable name column headings seperated with `|`\n- One or more subsequent rows of data supplied as template literal expressions using `${value}` syntax.\n\n##### `.test`:\n\n- name: `String` the title of the `test`, use `$variable` in the name string to inject test values into the test title from the tagged template expressions\n  - To inject nested object values use you can supply a keyPath i.e. `$variable.path.to.value`\n- testFn: `Function` the test logic, this is the function that will receive the parameters of each row as function arguments\n\n#### `each[tagged template].describe(name, suiteFn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.describe('$a + $b', ({a, b, expected}) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected);\n  });\n\n  test('does not mutate first arg', () => {\n    a + b;\n    expect(a).toBe(a);\n  });\n\n  test('does not mutate second arg', () => {\n    a + b;\n    expect(b).toBe(b);\n  });\n});\n```\n\n##### `each` takes a tagged template string with:\n\n- First row of variable name column headings seperated with `|`\n- One or more subsequent rows of data supplied as template literal expressions using `${value}` syntax.\n\n##### `.describe`:\n\n- name: `String` the title of the `test`, use `$variable` in the name string to inject test values into the test title from the tagged template expressions\n  - To inject nested object values use you can supply a keyPath i.e. `$variable.path.to.value`\n- suiteFn: `Function` the suite of `test`/`it`s to be ran, this is the function that will receive the parameters in each row as function arguments\n\n### Usage\n\n#### `.test(name, fn)`\n\nAlias: `.it(name, fn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.test('returns $expected when adding $a to $b', ({a, b, expected}) => {\n  expect(a + b).toBe(expected);\n});\n```\n\n#### `.test.only(name, fn)`\n\nAliases: `.it.only(name, fn)` or `.fit(name, fn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.test.only('returns $expected when adding $a to $b', ({a, b, expected}) => {\n  expect(a + b).toBe(expected);\n});\n```\n\n#### `.test.skip(name, fn)`\n\nAliases: `.it.skip(name, fn)` or `.xit(name, fn)` or `.xtest(name, fn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.test.skip('returns $expected when adding $a to $b', ({a, b, expected}) => {\n  expect(a + b).toBe(expected);\n});\n```\n\n#### Asynchronous `.test(name, fn(done))`\n\nAlias: `.it(name, fn(done))`\n\n```js\neach`\n  str\n  ${'hello'}\n  ${'mr'}\n  ${'spy'}\n`.test('gives 007 secret message: $str', ({str}, done) => {\n  const asynchronousSpy = message => {\n    expect(message).toBe(str);\n    done();\n  };\n  callSomeAsynchronousFunction(asynchronousSpy)(str);\n});\n```\n\n#### `.describe(name, fn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.describe('$a + $b', ({a, b, expected}) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected);\n  });\n\n  test('does not mutate first arg', () => {\n    a + b;\n    expect(a).toBe(a);\n  });\n\n  test('does not mutate second arg', () => {\n    a + b;\n    expect(b).toBe(b);\n  });\n});\n```\n\n#### `.describe.only(name, fn)`\n\nAliases: `.fdescribe(name, fn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.describe.only('$a + $b', ({a, b, expected}) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected);\n  });\n});\n```\n\n#### `.describe.skip(name, fn)`\n\nAliases: `.xdescribe(name, fn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.describe.skip('$a + $b', ({a, b, expected}) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected);\n  });\n});\n```\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/facebook/jest.git"
  },
  "version": "23.6.0"
}
