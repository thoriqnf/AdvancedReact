{
  "_args": [
    [
      {
        "raw": "graphql-middleware@1.6.6",
        "scope": null,
        "escapedName": "graphql-middleware",
        "name": "graphql-middleware",
        "rawSpec": "1.6.6",
        "spec": "1.6.6",
        "type": "version"
      },
      "/Users/thoriqnurfaizal/Documents/GitHub/AdvancedReact/Backend/node_modules/graphql-yoga"
    ]
  ],
  "_from": "graphql-middleware@1.6.6",
  "_hasShrinkwrap": false,
  "_id": "graphql-middleware@1.6.6",
  "_location": "/graphql-middleware",
  "_nodeVersion": "10.8.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/graphql-middleware_1.6.6_1533925538764_0.02199740404977013"
  },
  "_npmUser": {
    "name": "divyenduz",
    "email": "mail@divyendusingh.com"
  },
  "_npmVersion": "6.2.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "graphql-middleware@1.6.6",
    "scope": null,
    "escapedName": "graphql-middleware",
    "name": "graphql-middleware",
    "rawSpec": "1.6.6",
    "spec": "1.6.6",
    "type": "version"
  },
  "_requiredBy": [
    "/graphql-yoga"
  ],
  "_resolved": "https://registry.npmjs.org/graphql-middleware/-/graphql-middleware-1.6.6.tgz",
  "_shasum": "f40f4e836ced479df718dbc1869ea4cd3b64027b",
  "_shrinkwrap": null,
  "_spec": "graphql-middleware@1.6.6",
  "_where": "/Users/thoriqnurfaizal/Documents/GitHub/AdvancedReact/Backend/node_modules/graphql-yoga",
  "author": {
    "name": "Matic Zavadlal",
    "email": "matic.zavadlal@gmail.com"
  },
  "bugs": {
    "url": "https://github.com/graphcool/graphql-middleware/issues"
  },
  "dependencies": {
    "graphql-tools": "^3.0.5"
  },
  "description": "GraphQL Middleware done right!",
  "devDependencies": {
    "@types/graphql": "^0.12.4",
    "ava": "^0.25.0",
    "graphql": "^0.13.2",
    "prettier": "^1.11.1",
    "prettier-check": "^2.0.0",
    "rimraf": "^2.6.2",
    "semantic-release": "^15.1.7",
    "ts-node": "^7.0.0",
    "tslint": "^5.9.1",
    "tslint-config-prettier": "^1.10.0",
    "tslint-config-standard": "^7.0.0",
    "typescript": "^2.7.1"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-1rSSPEJOhBMwNCBCp5CCh3YZFvo8qN/pzQM8k50pd/w2hBsBvOx0AVU9Or6JQbTXxYrKFXvKFUxC5Lp+2oeUtw==",
    "shasum": "f40f4e836ced479df718dbc1869ea4cd3b64027b",
    "tarball": "https://registry.npmjs.org/graphql-middleware/-/graphql-middleware-1.6.6.tgz",
    "fileCount": 44,
    "unpackedSize": 141726,
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbbdijCRA9TVsSAnZWagAApd8QAJSBGodBXjWLob49Fb4u\nt+/fqW9qYxMuGonnD36lsD2ttyf8Zj4rmh5nSsGEE3kuygsSQIq+J9BLmYgB\nO4i6RDmiu+ox7G2FjMvfJjRAsaxZDL9Um8yP4dMwWC4hXYjur9yLnBmYW4zH\nriIdkWlgVHsCMmeS8QsVzVCERu+/94t8EmxAkKPK1o0SW6kxX9+rR+5MZmOY\nS6syJgg8MgJqGhI22gLZkXoq/DAtZ8T+8/V1mZjovMjNuv8fZ/APDs1g+69n\nV5BQNODOE5+68U8pQ+ovIKsCt4qfJU8TxXgKWyIr+p2MrBNqfMTP3ID4+u1q\nkhQgDMzXM2qkpJLTizQTUSrDrXeVUwcNL9H/b77jBuYfWLeBzvVmNwc0U8Tg\nmTowrmEuQtrrdbbk1FgoIc/7DKHlkYIJKLteCc0d2H3/sV5zghJ/gGO99X2/\ndo6MYrrQnQ+Szstmk0QRSv/86Q5QHgP9rXrByKBFvBcjAudl8alAUCoJYcg6\nttPrlTWb+aUMktbXCZdBu+fsa8EyWA8tn2yes1Te2Jqck4tvd1jmIZNJFaOt\n7TPKx222KCVmffQRrVfGwFKX2PLh1sL6kUAWCyH3xEBwypJwu7YqsDkfzlWp\nhFfp47gIsXisRYcaCn6IwwWFIUL6h9FGfHTN7Nr1ddZYGWcYLufgVCA3JEAH\nh4rR\r\n=pTZl\r\n-----END PGP SIGNATURE-----\r\n"
  },
  "files": [
    "dist"
  ],
  "gitHead": "7df7d8fa46d85a9d8e5ea9f230580babb27f0062",
  "homepage": "https://github.com/graphcool/graphql-middleware",
  "keywords": [
    "graphql",
    "middleware",
    "schema",
    "resolvers",
    "server",
    "prisma",
    "yoga"
  ],
  "license": "MIT",
  "main": "dist/index.js",
  "maintainers": [
    {
      "name": "arjanfrans",
      "email": "arjanfrans.com@gmail.com"
    },
    {
      "name": "schickling",
      "email": "schickling.j@gmail.com"
    }
  ],
  "name": "graphql-middleware",
  "optionalDependencies": {},
  "peerDependencies": {
    "graphql": "^0.13.2"
  },
  "readme": "<p align=\"center\"><img src=\"media/logo.png\" width=\"150\" /></p>\n\n# graphql-middleware\n\n[![CircleCI](https://circleci.com/gh/prismagraphql/graphql-middleware.svg?style=shield)](https://circleci.com/gh/prismagraphql/graphql-middleware)\n[![npm version](https://badge.fury.io/js/graphql-middleware.svg)](https://badge.fury.io/js/graphql-middleware)\n\nAll in one solution to manage middleware in your GraphQL projects.\n\n## Overview\n\nGraphQL Middleware is a schema wrapper which allows you to manage additional functionality across multiple resolvers efficiently.\n\n* **Easiest way to handle GraphQL middleware:** An intuitive, yet familiar API that you will pick up in a second.\n* **Powerful:** Allows complete control over your resolvers (Before, After).\n* **Compatible:** Works with any GraphQL Schema.\n* **Remote:** Accepts `fragments` in resolvers to connect with remote schemas.\n\n## Install\n\n```sh\nyarn add graphql-middleware\n```\n\n## How does it work\n\nGraphQL Middleware lets you run arbitrary code before or after a resolver is invoked. It improves your code structure by enabling code reuse and a clear separation of concerns.\n\n```ts\nconst { GraphQLServer } = require('graphql-yoga')\n\nconst typeDefs = `\ntype Query {\n  hello(name: String): String\n  bye(name: String): String\n}\n`\nconst resolvers = {\n  Query: {\n    hello: (root, args, context, info) => {\n      console.log(`3. resolver: hello`)\n      return `Hello ${args.name ? args.name : 'world'}!`\n    },\n    bye: (root, args, context, info) => {\n      console.log(`3. resolver: bye`)\n      return `Bye ${args.name ? args.name : 'world'}!`\n    },\n  },\n}\n\nconst logInput = async (resolve, root, args, context, info) => {\n  console.log(`1. logInput: ${JSON.stringify(args)}`)\n  const result = await resolve(root, args, context, info)\n  console.log(`5. logInput`)\n  return result\n}\n\nconst logResult = async (resolve, root, args, context, info) => {\n  console.log(`2. logResult`)\n  const result = await resolve(root, args, context, info)\n  console.log(`4. logResult: ${JSON.stringify(result)}`)\n  return result\n}\n\nconst server = new GraphQLServer({\n  typeDefs,\n  resolvers,\n  middlewares: [logInput, logResult],\n})\nserver.start(() => console.log('Server is running on http://localhost:4000'))\n```\n\nExecution of the middleware and resolver functions follow the \"onion\"-principle, meaning each middleware function adds a layer before and after the actual resolver invocation.\n\n<p align=\"center\"><img src=\"media/idea.png\" /></p>\n\n> The order of the middleware functions in the middlewares array is important. The first resolver is the \"most-outer\" layer, so it gets executed first and last. The second resolver is the \"second-outer\" layer, so it gets executed second and second to last... And so forth.\n\n> You can read more about GraphQL Middleware in this fantastic [article](https://www.prisma.io/blog/graphql-middleware-zie3iphithxy/).\n\n## Standalone usage\n\n```ts\nimport { applyMiddleware } from 'graphql-middleware'\nimport { makeExecutableSchema } from 'graphql-tools'\nimport { authMiddleware, metricsMiddleware } from './middleware'\n\n// Minimal example middleware (before & after)\nconst beepMiddleware = {\n  Query: {\n    hello: async (resolve, parent, args, context, info) => {\n      // You can you middleware to override arguments\n      const argsWithDefault = { name: 'Bob', ...args }\n      const result = await resolve(parent, argsWithDefault, context, info)\n      // Or change the returned values of resolvers\n      return result.replace(/Trump/g, 'beep')\n    },\n  },\n}\n\nconst typeDefs = `\n  type Query {\n    hello(name: String): String\n  }\n`\nconst resolvers = {\n  Query: {\n    hello: (parent, { name }, context) => `Hello ${name ? name : 'world'}!`,\n  },\n}\n\nconst schema = makeExecutableSchema({ typeDefs, resolvers })\n\nconst schemaWithMiddleware = applyMiddleware(\n  schema,\n  metricsMiddleware,\n  authMiddleware,\n  beepMiddleware,\n)\n```\n\n### Usage with `graphql-yoga`\n\n> `graphql-yoga` has built-in support for `graphql-middleware`!\n\n```ts\nimport { GraphQLServer } from 'graphql-yoga'\nimport { authMiddleware, metricsMiddleware } from './middleware'\n\nconst typeDefs = `\n  type Query {\n    hello(name: String): String\n  }\n`\nconst resolvers = {\n  Query: {\n    hello: (parent, { name }, context) => `Hello ${name ? name : 'world'}!`,\n  },\n}\n\nconst server = new GraphQLServer({\n  typeDefs,\n  resolvers,\n  middlewares: [authMiddleware, metricsMiddleware],\n  documentMiddleware: [],\n})\nserver.start(() => console.log('Server is running on localhost:4000'))\n```\n\n## Awesome Plugins [![Awesome](https://awesome.re/badge.svg)](https://awesome.re)\n\n* [graphql-middleware-apollo-upload-server](http://github.com/homeroom-live/graphql-middleware-apollo-upload-server) - Uploading files is hard, that's why this package manages it for you!\n* [graphql-shield](https://github.com/maticzav/graphql-shield) - Permissions as another layer of abstraction.\n* [graphql-middleware-sentry](https://github.com/maticzav/graphql-middleware-sentry) - Report your server errors to Sentry.\n* [graphql-middleware-forward-binding](https://github.com/maticzav/graphql-middleware-forward-binding) - GraphQL Binding forwardTo plugin for GraphQL Middleware.\n\n## API\n\nA middleware is a resolver function that wraps another resolver function.\n\n```ts\nexport declare type IMiddlewareResolver<\n  TSource = any,\n  TContext = any,\n  TArgs = any\n> = (\n  resolve: Function,\n  parent: TSource,\n  args: TArgs,\n  context: TContext,\n  info: GraphQLResolveInfo,\n) => Promise<any>\n\nexport interface IMiddlewareWithOptions<\n  TSource = any,\n  TContext = any,\n  TArgs = any\n> {\n  fragment?: IMiddlewareFragment\n  fragments?: IMiddlewareFragment[]\n  resolve?: IMiddlewareResolver<TSource, TContext, TArgs>\n}\n\nexport type IMiddlewareFunction<TSource = any, TContext = any, TArgs = any> =\n  | IMiddlewareWithOptions<TSource, TContext, TArgs>\n  | IMiddlewareResolver<TSource, TContext, TArgs>\n\ninterface IMiddlewareTypeMap {\n  [key: string]: IMiddlewareFunction | IMiddlewareFieldMap\n}\n\ninterface IMiddlewareFieldMap {\n  [key: string]: IMiddlewareFunction\n}\n\ntype IMiddleware = IMiddlewareFunction | IMiddlewareTypeMap\n\nfunction middleware(\n  generator: (schema: GraphQLSchema) => IMiddleware,\n): MiddlewareGenerator\n\nfunction applyMiddleware(\n  schema: GraphQLSchema,\n  ...middleware: (IMiddleware | MiddlewareGenerator)[]\n): GraphQLSchema & {\n  schema?: GraphQLSchema\n  fragmentReplacements?: FragmentReplacement[]\n}\n\n/**\n * Applies middleware to a schema like `applyMiddleware` but only applies the\n * middleware to fields that have non-default resolvers. This method can be\n * useful if you want to report performance of only non-trivial methods.\n */\nfunction applyMiddlewareToDeclaredResolvers(\n  schema: GraphQLSchema,\n  ...middleware: (IMiddleware | MiddlewareGenerator)[]\n): GraphQLSchema & {\n  schema?: GraphQLSchema\n  fragmentReplacements?: FragmentReplacement[]\n}\n```\n\n### Middleware Generator\n\nIn some cases, your middleware could depend on how your schema looks. In such situations, you can turn your middleware into a middleware generator. Middleware generators are denoted with function `middleware` and receive `schema` as the first argument.\n\n```ts\nconst schemaDependentMiddleware = middleware(schema => {\n  return generateMiddlewareFromSchema(schema)\n})\n\nconst schemaWithMiddleware = applyMiddleware(\n  schema,\n  schemaDependentMiddleware,\n  someOtherOptionalMiddleware,\n  etc,\n)\n```\n\n### Middleware Fragments\n\nFragments are a way of expressing what information your resolver requires to make sure it can execute correctly. They are primarily used in schema forwarding when the client might not always request all the fields your resolver demands. Because of that, we need to provide a way of telling what other information we need from a remote schema and that's why we use fragments.\n\nYou can read more about fragments in the [`graphql-binding`](https://github.com/graphql-binding/graphql-binding) repository and on [`graphql-tools`](https://www.apollographql.com/docs/graphql-tools/schema-transforms.html#Other) documentation website.\n\nGraphQL Middleware provides a convenient way to quickly and easily add fragments to your middleware. This might turn out particularly useful when your middleware depends on resolver data.\n\nWe've made fragments extremely flexible by using the general API which, if you have ever run over fragments, you probably already know.\n\n```ts\n// Schema wide - gets applied to every field.\nconst middlewareWithFragments = {\n  fragment: `fragment NodeID on Node { id }`,\n  resolve: (resolve, { id }, args, ctx, info) => {\n    const foo = doSomethingWithID(id)\n    return resolve(foo)\n  },\n}\n\n// Type wide - gets applied to every field of certain type.\nconst middlewareWithFragments = {\n  Query: {\n    fragment: `fragment NodeID on Node { id }`,\n    resolve: (resolve, { id }, args, ctx, info) => {\n      const foo = doSomethingWithID(id)\n      return resolve(foo)\n    },\n  },\n  Mutation: {\n    fragments: [\n      `fragment NodeID on Node { id }`,\n      `fragment NodeSecret on Node { secret }`,\n    ],\n    resolve: (resolve, parent, args, ctx, info) => {\n      return resolve(parent, customArgs)\n    },\n  },\n}\n\n// Field scoped - gets applied to particular field.\nconst middlewareWithFragments = {\n  Query: {\n    node: {\n      fragment: `fragment NodeID on Node { id }`,\n      resolve: (resolve, { id }, args, ctx, info) => {\n        const foo = doSomethingWithID(id)\n        return resolve(foo)\n      },\n    },\n    books: (resolve, parent, args, ctx, info) => {\n      return resolve(parent, customArgs)\n    },\n  },\n}\n\nconst { schema, fragmentReplacements } = applyMiddleware(\n  schema,\n  middlewareWithFragments,\n  someOtherMiddleware,\n)\n```\n\n> `graphql-middleware` automatically merges fragments from multiple middlewares if possible. Otherwise, validation function throws an error.\n\n## GraphQL Middleware Use Cases\n\n* Logging\n* Metrics\n* Input sanitisation\n* Performance measurement\n* Authorization\n* Caching\n* Tracing\n\n## FAQ\n\n### Can I use GraphQL Middleware without GraphQL Yoga?\n\nYes. Nevertheless, we encourage you to use it in combination with Yoga. Combining the power of `middlewares` that GraphQL Middleware offers, with `documentMiddleware` which Yoga exposes, gives you unparalleled control over the execution of your queries.\n\n### How does GraphQL Middleware compare to `directives`?\n\nGraphQL Middleware and `directives` tackle the same problem in a completely different way. GraphQL Middleware allows you to implement all your middleware logic in your code, whereas directives encourage you to mix schema with your functionality.\n\n### Should I modify the context using GraphQL Middleware?\n\nGraphQL Middleware allows you to modify the context of your resolvers, but we encourage you to use GraphQL Yoga's `documentMiddleware` for this functionality instead.\n\n## Help & Community [![Slack Status](https://slack.prisma.io/badge.svg)](https://slack.prisma.io)\n\nJoin our [Slack community](http://slack.prisma.io/) if you run into issues or have questions. We love talking to you!\n\n<p align=\"center\"><a href=\"https://oss.prisma.io\"><img src=\"https://imgur.com/IMU2ERq.png\" alt=\"Prisma\" height=\"170px\"></a></p>\n",
  "readmeFilename": "README.md",
  "release": {
    "branch": "master"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/graphcool/graphql-middleware.git"
  },
  "scripts": {
    "build": "rm -rf dist && tsc -d",
    "lint": "tslint --project tsconfig.json {src}/**/*.ts && prettier-check --ignore-path .gitignore {src,.}/{*.ts,*.js}",
    "prepublishOnly": "npm run test",
    "semantic-release": "semantic-release",
    "test": "npm run lint && npm run build && npm run test-ava",
    "test-ava": "ava --verbose"
  },
  "typescript": {
    "definition": "dist/index.d.ts"
  },
  "typings": "dist/index.d.ts",
  "version": "1.6.6"
}
